use super::{hand_garble::garble, to_i32_le};

fn rol8(input: u8, count: u8) -> u8 {
    (input << count) | input >> (8 - count)
}

pub(super) fn sap_hash(block_in: &[u8], key_out: &mut [u8]) {
    let mut buffer0 = [
        150, 95, 198, 83, 248, 70, 204, 24, 223, 190, 178, 248, 56, 215, 236, 34, 3, 209, 32, 143,
    ];
    let mut buffer1 = [0; 210];
    let mut buffer2 = [
        67, 84, 98, 122, 24, 195, 214, 179, 154, 86, 246, 28, 20, 63, 12, 29, 59, 54, 131, 177, 57,
        81, 74, 170, 9, 62, 254, 68, 175, 222, 195, 32, 157, 66, 58,
    ];
    let mut buffer3 = [0; 132];
    let mut buffer4 = [
        237, 37, 209, 187, 188, 39, 159, 2, 162, 169, 17, 0, 12, 179, 82, 192, 189, 227, 27, 73,
        199,
    ];
    let i0_index = [18, 22, 23, 0, 5, 19, 32, 31, 10, 21, 30];

    let (mut w, mut x, mut y, mut z);

    let block_words = block_in;

    // Load the input into the buffer
    for (i, v) in buffer1.iter_mut().enumerate() {
        let slice_index = ((i % 64) >> 2) * 4;
        let in_word = to_i32_le(&block_words[slice_index..slice_index + 4]);
        let in_byte = (in_word >> ((3 - (i % 4)) << 3)) as u8;
        *v = in_byte;
    }

    // Next a scrambling
    for i in 0..840 {
        // We have to do unsigned, 32-bit modulo, or we get the wrong indices
        x = buffer1[((i - 155) & 0xffffffff) % 210];
        y = buffer1[((i - 57) & 0xffffffff) % 210];
        z = buffer1[((i - 13) & 0xffffffff) % 210];
        w = buffer1[(i & 0xffffffff) % 210];
        buffer1[i % 210] = rol8(y, 5) + (rol8(z, 3) ^ w) - rol8(x, 7);
    }

    garble(
        &mut buffer0,
        &mut buffer1,
        &mut buffer2,
        &mut buffer3,
        &mut buffer4,
    );

    // Fill the output with 0xE1
    key_out[..16].iter_mut().for_each(|v| *v = 0xE1);

    // Now we use all the buffers we have calculated to grind out the output. First buffer3
    for i in 0..11 {
        // Note that this is addition (mod 255) and not XOR
        // Also note that we only use certain indices
        // And that index 3 is hard-coded to be 0x3d (Maybe we can hack this up by changing buffer3[0] to be 0xdc?
        if i == 3 {
            key_out[i] = 0x3d;
        } else {
            key_out[i] += buffer3[i0_index[i] * 4];
        }
    }

    // Then buffer0
    for i in 0..20 {
        key_out[i % 16] ^= buffer0[i];
    }

    // Then buffer2
    for i in 0..35 {
        key_out[i % 16] ^= buffer2[i];
    }

    // Do buffer1
    for i in 0..210 {
        key_out[i % 16] ^= buffer1[i];
    }

    // Now we do a kind of reverse-scramble
    for _ in 0..16 {
        for i in 0..16 {
            x = key_out[((i - 7) & 0xffffffff) % 16];
            y = key_out[i % 16];
            z = key_out[((i - 37) & 0xffffffff) % 16];
            w = key_out[((i - 177) & 0xffffffff) % 16];
            key_out[i] = rol8(x, 1) ^ y ^ rol8(z, 6) ^ rol8(w, 5);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::sap_hash;

    #[test]
    fn sap_hash1_test() {
        let base = [
            250, 156, 173, 77, 75, 104, 38, 140, 127, 243, 136, 153, 222, 146, 46, 149, 30, 0, 1,
            30, 131, 126, 116, 70, 103, 183, 229, 121, 248, 114, 3, 1, 135, 211, 193, 15, 43, 215,
            99, 206, 92, 172, 43, 121, 180, 55, 205, 159, 5, 224, 249, 188, 100, 108, 242, 29, 86,
            64, 196, 37, 163, 131, 145, 113, 201, 231, 98, 153, 207, 98, 201, 82, 124, 29, 52, 199,
            253, 12, 58, 214, 135, 115, 193, 99, 90, 126, 148, 28, 208, 247, 237, 162, 72, 6, 99,
            208, 178, 143, 35, 251, 209, 142, 63, 220, 66, 130, 224, 163, 157, 227, 111, 57, 150,
            211, 126, 255, 112, 28, 173, 46, 182, 169, 138, 148, 112, 71, 144, 100, 176, 173, 20,
            79, 162, 8, 111, 16, 255, 191, 220, 239, 69, 186, 120, 121, 8, 0, 1, 204, 52, 42, 94,
            91, 26, 103, 115, 194, 14, 33, 184, 34, 77, 248, 98, 72, 24, 100, 239, 129, 10, 174,
            46, 55, 3, 200, 129, 156, 35, 83, 157, 229, 245, 215, 73, 188, 91, 122, 38, 108, 73,
            98, 131, 206, 127, 3, 147, 122, 225, 246, 22, 222, 12, 21, 255, 51, 140, 202, 255, 176,
            158, 170, 187, 228, 15, 93, 95, 85, 143, 185, 127, 23, 49, 248, 247, 218, 96, 160, 236,
            101, 121, 195, 62, 169, 131, 18, 195, 182, 113, 53, 166, 105, 79, 248, 35, 5, 217, 186,
            92, 97, 95, 162, 84, 210, 177, 131, 69, 131, 206, 228, 45, 68, 38, 200, 53, 167, 165,
            246, 200, 66, 28, 13, 163, 241, 199, 236, 78, 39, 94, 253, 242, 232, 48, 151, 174, 112,
            251, 224, 0, 63, 28, 57, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 16, 9, 0, 0, 0, 0, 0, 0,
        ];
        let mut session_key = [0; 16];

        sap_hash(&base, &mut session_key);

        assert_eq!(
            [170, 2, 178, 244, 190, 148, 132, 227, 112, 190, 34, 95, 225, 116, 32, 11],
            session_key
        );
    }

    #[test]
    fn sap_hash2_test() {
        let base = [
            201, 231, 98, 153, 207, 98, 201, 82, 124, 29, 52, 199, 253, 12, 58, 214, 135, 115, 193,
            99, 90, 126, 148, 28, 208, 247, 237, 162, 72, 6, 99, 208, 178, 143, 35, 251, 209, 142,
            63, 220, 66, 130, 224, 163, 157, 227, 111, 57, 150, 211, 126, 255, 112, 28, 173, 46,
            182, 169, 138, 148, 112, 71, 144, 100, 176, 173, 20, 79, 162, 8, 111, 16, 255, 191,
            220, 239, 69, 186, 120, 121, 8, 0, 1, 204, 52, 42, 94, 91, 26, 103, 115, 194, 14, 33,
            184, 34, 77, 248, 98, 72, 24, 100, 239, 129, 10, 174, 46, 55, 3, 200, 129, 156, 35, 83,
            157, 229, 245, 215, 73, 188, 91, 122, 38, 108, 73, 98, 131, 206, 127, 3, 147, 122, 225,
            246, 22, 222, 12, 21, 255, 51, 140, 202, 255, 176, 158, 170, 187, 228, 15, 93, 95, 85,
            143, 185, 127, 23, 49, 248, 247, 218, 96, 160, 236, 101, 121, 195, 62, 169, 131, 18,
            195, 182, 113, 53, 166, 105, 79, 248, 35, 5, 217, 186, 92, 97, 95, 162, 84, 210, 177,
            131, 69, 131, 206, 228, 45, 68, 38, 200, 53, 167, 165, 246, 200, 66, 28, 13, 163, 241,
            199, 236, 78, 39, 94, 253, 242, 232, 48, 151, 174, 112, 251, 224, 0, 63, 28, 57, 128,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 9, 0, 0, 0, 0, 0, 0,
        ];
        let mut session_key = [0; 16];

        sap_hash(&base, &mut session_key);
        assert_eq!(
            [101, 84, 162, 206, 230, 98, 105, 139, 92, 111, 197, 135, 6, 118, 40, 226],
            session_key
        );
    }
}
